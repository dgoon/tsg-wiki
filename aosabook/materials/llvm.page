---
format: rst
title: LLVM on AOSABOOK
...

 이 챕터는 LLVM 을 만들어온 디자인 결정사항들에 대해 이야기한다. LLVM은 어셈블러, 컴파일러, 디버거 등의 저수준 툴체인 셋을 아우르는 프로젝트이다. 기존 유닉스 시스템에서 쓰이던 툴과 호환되도록 디자인 되었다. "LLVM"은 원래 약자였지만(Low-Level Virtual Machine) 이제는 관련 프로젝트를 총괄하는 프로젝트 브랜드가 되었다. LLVM은 그 자체만의 기능 뿐 아니라 훌륭한 관련 도구들(CLang 같은...)로도 유명하지만, LLVM 을 다른 컴파일러들과 구분해주는 가장 큰 특징은 그 아키텍쳐에 있다.

 2000년 12월에 처음 프로젝트가 시작되었을 때 부터, LLVM은 잘 정의된 인터페이스를 가진 **재사용 가능한 라이브러리 모음**이 되도록 디자인되었다. 당시에 오픈소스 프로그래밍 언어의 구현들은 보통 하나의 실행파일로 이루어진 특정 용도 전용으로 설계되었다. 예를 들어 정적인 컴파일러로부터 파서를 뽑아내서 정적분석이나 리팩토링을 위해 재사용하는 것은 매우 어려운 일이다. - GCC를 생각해보라! 반면 스크립트 언어들은 보다 큰 프로그램에 런타임/해석기를 내장하는 경우가 많은데, 보통 그 런타임은 하나의 거대한 코드덩어리로 그 일부를 재사용하는 것도 어려울 뿐더러 여러 언어 구현에 공유되는 경우도 거의 없다.

 컴파일러 그 자체의 구성 이외에도, 인기있는 언어 구현체를 사용하는 커뮤니티는 보통 대단히 편파적이다. 구현체는 보통 전통적인 컴파일러(GCC, FreePascal같은...)를 제공하거나 혹은 인터프리터나 JIT(Just-In-Time) 컴파일러를 제공한다. 이 양쪽을 모두 지원하는 언어 구현체를 대단히 희귀하고, 있던 경우에도 이 양쪽 구현은 거의 코드를 공유하지 않았다.

 지난 10년간 LLVM은 이런 구도를 상당히 많이 바꾸어 냈다. LLVM은 요즘 정적 컴파일러, 런타임 컴파일러 양쪽 전반에 걸쳐 폭넓게 사용되는 전반 기술이다. 또한, 여러개의 특수화된 전용 컴파일러를 대체하기도 했다. 예를 들면, 애플의 OpenGL 스택이나 어도비 After Effect의 이미지 프로세싱 라이브러리 같은 부분에 사용되었다. 마지막으로 LLVM은 새 제품을 만드는 데에도 많이 사용되는데, 아마 가장 잘 알려진 것은 OpenCL GPU 프로그래밍 언어와 런타임일 것이다.

1. A Quick Introduction to Classical Compiler Design

 전통적인 정적 컴파일러(대부분의 C 컴파일러)의 가장 흔한 설계는 3단계 설계이다. 3단계 설계는 프론트엔드(Frontend), 최적화모듈(Optimizer), 백엔드(Backend)의 3개 컴포넌트로 구성된다.

 .. image:: http://www.aosabook.org/images/llvm/SimpleCompiler.png

 각 컴포넌트는:

Frontend
  소스코드 파싱, 에러검사, 입력 코드를 나타내는 언어마다의 `AST<http://en.wikipedia.org/wiki/Abstract_syntax_tree>`_(Abstract Syntax Tree) 를 생성하는 일을 한다. AST는 최적화를 위해 별도의 형식으로 표현될 수 있다.

Optimizer
  코드의 실행 속도를 향상시키기 위한 여러가지 변환 작업(예: 중복 계산 제거)을 한다. 이런 작업은 보통 언어/타겟 아키텍쳐와 독립적이다.

Backend
  코드 생성기라고도 한다. 코드를 타겟 명령어셋에 맞도록 변환한다. *올바른* 코드를 생성하는 것은 물론이고, 아키텍쳐에서 지원하는 특징을 잘 사용하여 *좋은* 코드를 생성해야 한다. 컴파일러 백엔드는 보통 명령어 선택, 레지스터 할당, 명령 스케쥴링 등을 작업을 한다.

 이 모델은 인터프리터나 JIT 컴파일러에도 똑같이 잘 적용된다. 자바 가상 머신(JVM)도 자바 바이트코드를 프론트엔드와 최적화 사이의 인터페이스로 사용하는 이 모델-3단계 디자인-의 구현체이다.

 - Implications of this Design

  이 클래식한 설계의 가장 중요한 이점은 컴파일러가 여러가지 소스 언어, 혹은 여러개의 타겟 아키텍쳐를 지원하고자 할 때 생긴다. 만약 컴파일러가 최적화 단계에서 하나의 코드 표현을 사용한다면, 프론트엔드는 어떤 언어라도 그 코드 표현으로 컴파일 하기만 하면 되고, 백엔드는 그 코드 표현에 대해서만 만들어지면 된다. 아래 그림을 참고하자.

  .. image:: http://www.aosabook.org/images/llvm/RetargetableCompiler.png

  이 설계에서는, 새로운 소스 언어를 지원하기 위한 작업은 새 프론트엔드의 구현 뿐이다. 기존의 최적화 모듈과 백엔드는 재사용할 수 있기 때문이다. 만약 각 부분들이 분리되어 있지 않다면, 새 소스 언어의 구현은 바닥부터 작업해야 하는 일이 되고, N 개의 타겟과 M 개의 소스 언어를 지원하기 위해서 N*M 개의 컴파일러를 필요로 하게 된다.

  3단계 구현의 또 다른 이점은 (위의 장점과 직접적으로 연관되었다) 여러개의 언어를 지원함으로써 컴파일러가 더 넓은 프로그래머들에게 쓰일 수 있고, 따라서 더 큰 커뮤니티를 형성할 수 있다는 점이다. 더 큰 커뮤니티는 더 많은 기여자를 이끌어내고, 자연스럽게 더 많은 개선이 가능하다. 이게 바로 GCC 같이 많은 커뮤니티에서 쓰이는 컴파일러가 FreePASCAL같이 좁은 범위에서 사용되는 컴파일러보다 최적화가 잘 된 기계어를 생성해내는 이유가 된다. 하지만 상용 컴파일러같은 경우에는 예산이 코드의 질로 바로 연결되기 때문에 경우가 조금 다르다고 할 수 있다. 예를 들어서 ICC 컴파일러는 좁은 사용자층에도 불구하고 훌륭한 코드를 생성해 낸다고 알려져 있다.

  3단계 구현의 마지막 이점은, 각 3개 컴포넌트를 구현하는데 필요한 기술이 다르다는 점이다. 필요 기술을 분리하는 것은 각 컴포넌트를 작업하는 사람이 맡은 부분을 개선하고 유지해나가는 것을 보다 쉽게 만들어준다. 이것이 기술이 아닌 **사회적**인 이슈이긴 하지만 실제적으로 아주 중요하다. 특히나, 이런 오픈소스 프로젝트가 기여를 받기 위한 진입장벽을 낮추는 데에 크게 도움이 된다.

2. Existing Language Implementation

3. LLVM's Code Representation: LLVM IR

 - Writing an LLVM IR Optimization

4. LLVM's Implementation of Three-Phase Design

  - LLVM IR is a Complete Code Representation

  - LLVM IR is a Collection of Libraries

5. Design of the Retargetable LLVM Code Generator

  - LLVM Target Description Files

6. Interesting Capabilities Provided by a Modular Design

  - Choosing When and Where Each Phase Runs

  - Unit Testing the Optimizer

  - Automatic Test Case Reduction with BugPoint

7. Retrospective and Future Directions






* written in c++

Compiler design
    Three phase: Frontend -> Optimizer -> Backend
    What's the strength of three-phase design?
    Success stories:
        Java and .NET virtual machines
        Translate input source code into C
        GCC
    Why one more?

LLVM IR
    Ref: http://llvm.org/docs/LangRef.html
    LLVM IR is a low-level RISC-like virtual instructino set.
    Like most RISC instruction sets:
        * Support leniar sequence of simple instructions: add, sub, compare and branch
        * Three-address form
        * Support labels
    Unlike most RISC instruction sets:
        * Strongly typed with a simple type system
        * Some details of the machine are abstracted
        * Uses an infinite set of temporaries named with a % character
    Defined in three isomorphic form:
        * Textual (.ll)
        * In-memory structure
        * Bitcode (.bc)
        * llvm-as: .ll -> .bc
        * llvm-dis: .bc -> .ll
    Intermediate representation can be a 'perfect world' for the compiler optimizer
    Should be easy for a frontend to generate
    Should be expressive enough to allow important optimizations to be performed for real targets


Three-phase

    * Frontend: Parsing, validating and diagnosing erros. Then traslate parsed code into LLVM IR
    * Optimizer: Takes LLVM IR and write out LLVM IR.
    * Code generator: Convert LLVM IR into machine code
    Looks like pipelining, and it really is.


    * LLVM IR is complete code representation
    * LLVM is a collection of libraries

