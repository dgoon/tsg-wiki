---
title: Git @ Aosabook
...

# Git

텍스트는 [http://www.aosabook.org/en/git.html]() <- 여기 있습니다.  

책을 읽고, 내용을 요약/정리하여 스터디원들에게 전달하기 위한 자료를 만듭니다. 이 페이지의 목적은  *git 이 다른 유사 프로그램들과 어떻게 다른가*, 몇몇 간단한 git 명령어를 사용할 때 *내부적으로 어떤 일이 일어나는가*를 당신이 **대충** 이해할 수 있는 쉬운 설명을 제공하는 것입니다. ... 짧게 말하자면 **쉬운 설명을 할 수 있을 정도로 내가 git을 잘 이해하기**가 목표입니다. 텍스트에서도 이야기하지만 git 의 커맨드는 정말 많고도 방대해서 완벽히 다 알려고 하는건 마치 C++ 을 정복하겠다는 정도로 부질없는 일입니다 ... 적당히 철학 및 설계를 이해하고, 자주 쓰는 명령부터 익혀가면 될 듯 합니다. 하지만 이 문서는 git 사용법에 대해 다루진 않습니다. 튜토리얼을 원하는 사람들이 ~~아마~~ 많을테니, 적절한 포탈을 앞에 배치하겠습니다. 귀찮으니 앞으로는 반말.

## Portals for git learners

  + [http://git-scm.com/book]()
  + [http://marklodato.github.com/visual-git-guide/index-en.html]()
  + [http://www.vogella.com/articles/Git/article.html]()
  + [http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html]()
  + [http://rogerdudler.github.com/git-guide/index.ko.html]()


## Git 이 뭐야?

여러 소스 코드 관리(SCM: Source Code Management) 시스템 중 하나이다. Subversion, CVS, Mercurial, Perforce 등 여러가지 비슷한 목적으로 만들어진 프로그램들이 있으며, 이들 사이에서는 구분되는 특징은

  1. 로컬 커밋이 가능
  2. 분산된 개발 흐름을 지원
  3. 저장소는 DAG 구조의 객체 데이터베이스
  4. 빠름
  5. 커맨드가 복잡함

정도가 있다.

## 이거 왜 만들었어?

### 태동

Git 이 리눅스 커널 커뮤니티에서 사용하기 위해 만들어졌다는 이야기는 개발자라면 거의 다 알고 있을만한 유명한 이야기다. 그런데 리눅스 커널은 당시의(그리고 지금도) 대부분의 소프트웨어 코드베이스와는 매우 다른 예외적인 경우에 속한다. 코드베이스에 커밋하는 커미터(Committer)도 많을 뿐더러, 패치를 보내오는 공헌자(Contributor)는 더 많고, 이 많은 사람들이 코드베이스에 대해 이해하고 있는 정도도 천차만별이다.

초기에 리눅스 커널은 많은 초보 개발자들이 쓰는 방법인, 1. 압축해두기 + 2. 변경사항 모아두기, 로 유지되어 왔으며, 이건 안되겠다 싶었던 커널 개발자들은 자신들에게 맞는 VCS(Version Control System)를 찾기 위해 고군분투했다. Git 은 이런 와중에 2005년에 시작된 오픈소스 프로젝트이다. Git 프로젝트가 시작될 당시 리눅스 커널은 BitKeeper 와 CVS 두개의 저장소에, 서로 다른 개발자의 손으로 관리되고 있었다. BitKeeper는 당시 다른 VCS 에서 제공되는 것과는 좀 다른 이력 보기 기능을 가지고 있었다. BitKeeper 를 만든 BitMover 가 커널 개발자들의 라이센스를 취소하겠다고 발표하자 리눅스의 아버지 *리누스 토발즈*가 후다닥 뭔가를 만들기 시작했는데, 이게 git 이 되었다.

### 목표

리누스가 처음 작성한 것은 스크립트 묶음이었는데, 이는 이메일로 날아오는 패치들을 순서대로 적용하는 일을 했다. 이 초기 스크립트 묶음의 목표는 여러 패치를 연속적으로 머지하는 작업을 빨리 할 수 있도록 하는 것이었다. 이 초기 결과물로부터 연결되는 git 의 디자인 목표는,

1. BitKeeper 가 보여주던 것과 유사한 분산 작업 흐름을 지원
2. 데이터 오류로부터 안전한 보호
3. 빠름

이렇게 3가지였고, 철학적으로는 anti CVS 를 지향했다. 참여자가 많고, 거대하고, 많은 작업 가지, 더 많은 패치를 다루어야 하는 커널 개발자가 원했던 것이 무엇인지 명확하게 확인할 수 있다. 비슷한 시기에 시작된 다른 **분산**VCS 들이 세개가 더 있는걸로 보아서, 목표 1번 **분산 작업 흐름을 지원** 은 인터넷의 발전으로 인한 시대의 요구였던게 아닐까 한다.

## VCS 의 기본

일단 일반적인 VCS 의 핵심 기능이 무엇인지를 살펴보자.

1. 데이터를 저장
2. 데이터의 변화를 추적
3. 내용과 변화 이력을 다른 협업자들에게 공개

가 핵심이다. 이 중 3번째는 모든 VCS 에게 필수적은 것은 아니지만, 요즘 오픈 소스 커뮤니티에서 개발되는 대부분의 프로젝트에서 중요한 요소이다. 이 각각에 대한 이야기를 해 보도록 한다. 일반적인(혹은 다른) VCS의 이야기와 Git이 어떤 선택을 했는지를 비교해서 다루겠다. 각 디자인 선택에 대한 자세한 이야기는 이후에 나오게 된다.

### 데이터 저장

VCS에서 데이터를 저장하는 일반적인 디자인은 두 가지가 있다. 하나는 바뀐 부분을 Changeset 으로 나타내는 방법이고, 또 하나는 DAG 방식의 데이터 표기 방법을 사용하는 것이다.

Changeset 은 저장된 데이터 전체를 놓고 두 버전의 다른 부분을 약간의 메타정보와 함께 묶어낸다. DAG 으로 데이터를 나타내기 위해서는 파일시스템 트리의 현 상태를 그대로 반영하기 위한 객체들이 필요하다. Git은 몇 가지 다른 타입의 객체들을 사용해서 DAG 방식의 데이터 표기를 사용한다.

### 커밋과 머지

대부분의 VCS 소프트웨어는 역사 및 변화 이력 추적에,

1. 선형 표현
2. 역사를 DAG 구성으로 표현

중 한 가지를 선택하다. 변화 이력을 선형으로 표현한다는 뜻은, 다 하나의 역사만이 존재한다는 뜻이다. Subversion, cvs 등이 이런 방식을 채택하고 있다. Git은 변화 이력을 저장하기 위해 DAG 구조를 사용한다. Git 의 커밋은 메타데이터와 함께 조상에 대한 정보를 가지는데, 조상은 이론상 0개에서 무한대까지의 커밋이 된다. 예를 들어 Git 저장소의 최초 커밋은 부모가 하나도 없는 커밋이 될 것이다. 만약 3개의 커밋을 머지했다며, 3개의 조상을 가지는 커밋이 생기게 된다.

즉, Git 의 커밋은 아래의 예와 같은 구조를 가지게 된다. 이런 DAG 표현은 특히 작업 가지를 다루는 데에 편리함을 준다. 풀어서 설명하면,

![Example of DAG representation for a commit](/aosabook/materials/git/dag-example.png)

+ 서로 다른 커밋에 속해 있더라도 각 노드의 ID 값이 같다면, 두 노드는 같은 내용을 가지고 있다고 보장한다. 이는 Git 이 내용의 의 다른 점을 효과적으로 파악할 수 있게 해 준다.
+ 두 브랜치를 머지할 때, DAG 안에 있는 두 노드를 머지하게 된다. DAG 구조는 효율적으로 공통 선조를 찾아낼 수 있게 해 준다.

더 자세한 이야기는 뒤쪽에 나오게 된다.

### 배포

VCS 는 프로젝트의 작업 내용을 동료에게 전달하는 데에 다음 3가지 중 하나의 입장을 취한다.

1. 지원하지 않는다.
2. 중앙 서버를 통한다: CVS, Subversion, Git
3. 분산 모델: Git, Mercurial, .... 중앙 서버같은 역할을 하는 저장소가 공동 작업자들에게 각각 존재한다.

Alex 가 동일한 내용을 가지고 있는 Subversion, Git 저장소에 똑같은 내용을 수정했다고 해 보자.

Subversion 저장소에서 커밋을 하면, 로컬 작업 디렉토리에서는 가장 최근 변경내용이 적용되고 메타데이터가 변하게 된다. 중앙 저장소 서버에서는 이전 스냅샷과 비교해 해당 파일이 바뀐 내용이 생성되고, 그 변경 내용이 서버에 저장된다. 이게 중앙 서버에 적용되면 다른 작업자가 해당 내용을 가져가 사용할 수 있게 된다.

Git 저장소에서는 커밋을 하면 먼저 로컬 저장소에만 반영이 된다. 로컬 커밋은 위에서 설명한 것과 같은 DAG 구조로 바뀐 디렉토리 및 파일들에 대한 내용을 가지고 있다. 주의할 점은, 바뀐 부분이 아니라 **변화가 생긴 파일 내용을 통째로** 들고 있다는 점이다. 그리고 변화가 생긴 파일들을 가지고 있는 디렉토리들은 새 노드가 생성되어 이전의 노드를 대체한다. 디렉토리가 변하면 이를 포함하는 디렉토리 역시 변한 것이기 때문에, 이 변화는 루트 디렉토리까지 주욱 이어진다. 따라서 루트 디렉토리의 ID는 매 커밋마다 언제나 바뀌게 된다. 이 새로운 DAG 구조에서 바뀌지 않은 부분은 이전 DAG(commit이 가리키는 ancestor)에 있는 것을 그대로 사용하고, 바뀐 부분만 새 내용으로 대체하게 되면 새로운 snapshot 이 나온다.

이렇게 만들어진 로컬 커밋을 다른 사람과 공유하기 위해서는, 1. Alex가 다른 사람에게 변경 내용을 보내주기(push), 2. 다른 사람이 Alex의 저장소로부터 변경 내용을 가져가기(pull), 두 가지의 방법이 있다. 어느 쪽이건 다른 저장소에 로컬에서 생긴것과 같은 커밋 및 그에 포함된 객체들이 원격 저장소의 해당 브랜치에 생성되며, 원격 저장소의 작업자는 이렇게 전달된 내용을 검토 후 자신의 작업 브랜치에 머지하거나 새 브랜치를 생성하여 작업을 할 수 있다.

Subversion의 경우와는 달리 Git 모델에서는 작업자가 언제 자신의 작업 내용을 공유할지 선택할 수가 있으며, 이는 공동 작업에서 작업 흐름 관리에 큰 유연성을 준다. 변경 내용이 작은 경우에는 subversion 에서와 같이 바뀐 부분만 저장하는 방식이 바뀐 파일 내용을 모든 커밋이 들고 있는 git의 방식보다 공간 효율성이 더 좋을 수 있다. 이 공간 효율성의 문제에 대해서 git 은 몇 가지 대책을 가지고 있으며, 이는 문서의 뒤쪽에서 설명하게 된다.


## Git 의 선택: The Toolkit

Git은 최초 Linus가 작성한 방식, 그리고 리눅스 커뮤니티에서 시작된 연유로 인해 작은 커맨드라인 도구로 이루어진 툴킷 방식으로 만들어져 있다. 이는 유닉스 커뮤니티의 전통적인 디자인 철학이다. 초기 git 툴킷의 일부는 아예 shell script로 쓰이기도 했는데, 이것이 이식성 문제의 주된 원인이 되기도 했다.

툴킷은 크게 두 부분으로 나뉘는데, 1. Plumbing, 2. Porcelain 파트이다. Plumbing 파트는 저수준의 이력 추적 및 DAG 관련 커맨드라인이 들어있고, Porcelain 파트는 저장소를 다루거나 저장소간의 데이터 전송을 담당하는 작은 명령어들을 가지고 있다.

툴킷 디자인이 스크립트 작성자들에게는 충분한 수준의 커맨드를 제공하고 있지만, 프로그램 개발자들은 자신들의 프로그램에서 링크 가는한 라이브러리가 없다고 불평한다. Git 바이너리가 *die()* 함수를 부르기 때문에 재진입이 가능하지 않고, 대부분의 GUI나 웹 인터페이스 혹은 오랫동안 실행되어야 하는 서비스들에서는 git 실행을 위해서 fork/exec 등을 불러야 하고, 따라서 느리다.

이런 상황을 개선하기 위해 [libgit2](http://libgit2.github.com/) 같은 프로젝트가 진행되고 있다.

## Git internal

### 3단콤보 저장구조

### Object database

### 작업 가지(branch) & 가지잇기(merge)

