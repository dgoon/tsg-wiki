---
title: Git @ Aosabook
...

# Git

텍스트는 [http://www.aosabook.org/en/git.html]() <- 여기 있습니다.  

책을 읽고, 내용을 요약/정리하여 스터디원들에게 전달하기 위한 자료를 만듭니다. 이 페이지의 목적은  *git 이 다른 유사 프로그램들과 어떻게 다른가*, 몇몇 간단한 git 명령어를 사용할 때 *내부적으로 어떤 일이 일어나는가*를 당신이 **대충** 이해할 수 있는 쉬운 설명을 제공하는 것입니다. ... 짧게 말하자면 **쉬운 설명을 할 수 있을 정도로 내가 git을 잘 이해하기**가 목표입니다. 텍스트에서도 이야기하지만 git 의 커맨드는 정말 많고도 방대해서 완벽히 다 알려고 하는건 마치 C++ 을 정복하겠다는 정도로 부질없는 일입니다 ... 적당히 철학 및 설계를 이해하고, 자주 쓰는 명령부터 익혀가면 될 듯 합니다. 하지만 이 문서는 git 사용법에 대해 다루진 않습니다. 튜토리얼을 원하는 사람들이 ~~아마~~ 많을테니, 적절한 포탈을 앞에 배치하겠습니다. 귀찮으니 앞으로는 반말.

## Portals for git learners

  + [http://git-scm.com/book]()
  + [http://marklodato.github.com/visual-git-guide/index-en.html]()
  + [http://www.vogella.com/articles/Git/article.html]()
  + [http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html]()
  + [http://rogerdudler.github.com/git-guide/index.ko.html]()


## Git 이 뭐야?

여러 소스 코드 관리(SCM: Source Code Management) 시스템 중 하나이다. Subversion, CVS, Mercurial, Perforce 등 여러가지 비슷한 목적으로 만들어진 프로그램들이 있으며, 이들 사이에서는 구분되는 특징은

  1. 로컬 커밋이 가능
  2. 분산된 개발 흐름을 지원
  3. 저장소는 DAG 구조의 객체 데이터베이스
  4. 빠름
  5. 커맨드가 복잡함

정도가 있다.

## 이거 왜 만들었어?

### 태동

Git 이 리눅스 커널 커뮤니티에서 사용하기 위해 만들어졌다는 이야기는 개발자라면 거의 다 알고 있을만한 유명한 이야기다. 그런데 리눅스 커널은 당시의(그리고 지금도) 대부분의 소프트웨어 코드베이스와는 매우 다른 예외적인 경우에 속한다. 코드베이스에 커밋하는 커미터(Committer)도 많을 뿐더러, 패치를 보내오는 공헌자(Contributor)는 더 많고, 이 많은 사람들이 코드베이스에 대해 이해하고 있는 정도도 천차만별이다.

초기에 리눅스 커널은 많은 초보 개발자들이 쓰는 방법인, 1. 압축해두기 + 2. 변경사항 모아두기, 로 유지되어 왔으며, 이건 안되겠다 싶었던 커널 개발자들은 자신들에게 맞는 VCS(Version Control System)를 찾기 위해 고군분투했다. Git 은 이런 와중에 2005년에 시작된 오픈소스 프로젝트이다. Git 프로젝트가 시작될 당시 리눅스 커널은 BitKeeper 와 CVS 두개의 저장소에, 서로 다른 개발자의 손으로 관리되고 있었다. BitKeeper는 당시 다른 VCS 에서 제공되는 것과는 좀 다른 이력 보기 기능을 가지고 있었다. BitKeeper 를 만든 BitMover 가 커널 개발자들의 라이센스를 취소하겠다고 발표하자 리눅스의 아버지 *리누스 토발즈*가 후다닥 뭔가를 만들기 시작했는데, 이게 git 이 되었다.

### 목표

리누스가 처음 작성한 것은 스크립트 묶음이었는데, 이는 이메일로 날아오는 패치들을 순서대로 적용하는 일을 했다. 이 초기 스크립트 묶음의 목표는 여러 패치를 연속적으로 머지하는 작업을 빨리 할 수 있도록 하는 것이었다. 이 초기 결과물로부터 연결되는 git 의 디자인 목표는,

1. BitKeeper 가 보여주던 것과 유사한 분산 작업 흐름을 지원
2. 데이터 오류로부터 안전한 보호
3. 빠름

이렇게 3가지였고, 철학적으로는 anti CVS 를 지향했다. 참여자가 많고, 거대하고, 많은 작업 가지, 더 많은 패치를 다루어야 하는 커널 개발자가 원했던 것이 무엇인지 명확하게 확인할 수 있다. 비슷한 시기에 시작된 다른 **분산**VCS 들이 세개가 더 있는걸로 보아서, 목표 1번 **분산 작업 흐름을 지원** 은 인터넷의 발전으로 인한 시대의 요구였던게 아닐까 한다.

## VCS 의 기본

일단 일반적인 VCS 의 핵심 기능이 무엇인지를 살펴보자.

1. 데이터를 저장
2. 데이터의 변화를 추적
3. 내용과 변화 이력을 다른 협업자들에게 공개

가 핵심이다. 이 중 3번째는 모든 VCS 에게 필수적은 것은 아니지만, 요즘 오픈 소스 커뮤니티에서 개발되는 대부분의 프로젝트에서 중요한 요소이다. 이 각각에 대한 이야기를 해 보도록 한다. 일반적인(혹은 다른) VCS의 이야기와 Git이 어떤 선택을 했는지를 비교해서 다루겠다. 각 디자인 선택에 대한 자세한 이야기는 이후에 나오게 된다.

### 데이터 저장

VCS에서 데이터를 저장하는 일반적인 디자인은 두 가지가 있다. 하나는 바뀐 부분을 Changeset 으로 나타내는 방법이고, 또 하나는 DAG 방식의 데이터 표기 방법을 사용하는 것이다.

Changeset 은 저장된 데이터 전체를 놓고 두 버전의 다른 부분을 약간의 메타정보와 함께 묶어낸다. DAG 으로 데이터를 나타내기 위해서는 파일시스템 트리의 현 상태를 그대로 반영하기 위한 객체들이 필요하다. Git은 몇 가지 다른 타입의 객체들을 사용해서 DAG 방식의 데이터 표기를 사용한다.

### 커밋과 머지

대부분의 VCS 소프트웨어는 역사 및 변화 이력 추적에,

1. 선형 표현
2. 역사를 DAG 구성으로 표현

중 한 가지를 선택하다. 변화 이력을 선형으로 표현한다는 뜻은, 단 하나의 역사만이 존재한다는 뜻이다. Subversion, cvs 등이 이런 방식을 채택하고 있다. Git은 변화 이력을 저장하기 위해 DAG 구조를 사용한다. Git 의 커밋은 메타데이터와 함께 조상에 대한 정보를 가지는데, 조상은 이론상 0개에서 무한대까지의 커밋이 된다. 예를 들어 Git 저장소의 최초 커밋은 부모가 하나도 없는 커밋이 될 것이다. 만약 3개의 커밋을 머지했다며, 3개의 조상을 가지는 커밋이 생기게 된다.

즉, Git 의 커밋은 아래의 예와 같은 구조를 가지게 된다. 이런 DAG 표현은 특히 작업 가지를 다루는 데에 편리함을 준다. 풀어서 설명하면,

![Example of DAG representation for a commit](/aosabook/materials/git/dag-example.png)

+ 서로 다른 커밋에 속해 있더라도 각 노드의 ID 값이 같다면, 두 노드는 같은 내용을 가지고 있다고 보장한다. 이는 Git 이 내용의 의 다른 점을 효과적으로 파악할 수 있게 해 준다.
+ 두 브랜치를 머지할 때, DAG 안에 있는 두 노드를 머지하게 된다. DAG 구조는 효율적으로 공통 선조를 찾아낼 수 있게 해 준다.

더 자세한 이야기는 뒤쪽에 나오게 된다.

### 배포

VCS 는 프로젝트의 작업 내용을 동료에게 전달하는 데에 다음 3가지 중 하나의 입장을 취한다.

1. 지원하지 않는다.
2. 중앙 서버를 통한다: CVS, Subversion, Git
3. 분산 모델: Git, Mercurial, .... 중앙 서버같은 역할을 하는 저장소가 공동 작업자들에게 각각 존재한다.

Alex 가 동일한 내용을 가지고 있는 Subversion, Git 저장소에 똑같은 내용을 수정했다고 해 보자.

Subversion 저장소에서 커밋을 하면, 로컬 작업 디렉토리에서는 가장 최근 변경내용이 적용되고 메타데이터가 변하게 된다. 중앙 저장소 서버에서는 이전 스냅샷과 비교해 해당 파일이 바뀐 내용이 생성되고, 그 변경 내용이 서버에 저장된다. 이게 중앙 서버에 적용되면 다른 작업자가 해당 내용을 가져가 사용할 수 있게 된다.

Git 저장소에서는 커밋을 하면 먼저 로컬 저장소에만 반영이 된다. 로컬 커밋은 위에서 설명한 것과 같은 DAG 구조로 바뀐 디렉토리 및 파일들에 대한 내용을 가지고 있다. 주의할 점은, 바뀐 부분이 아니라 **변화가 생긴 파일 내용을 통째로** 들고 있다는 점이다. 그리고 변화가 생긴 파일들을 가지고 있는 디렉토리들은 새 노드가 생성되어 이전의 노드를 대체한다. 디렉토리가 변하면 이를 포함하는 디렉토리 역시 변한 것이기 때문에, 이 변화는 루트 디렉토리까지 주욱 이어진다. 따라서 루트 디렉토리의 ID는 매 커밋마다 언제나 바뀌게 된다. 이 새로운 DAG 구조에서 바뀌지 않은 부분은 이전 DAG(commit이 가리키는 ancestor)에 있는 것을 그대로 사용하고, 바뀐 부분만 새 내용으로 대체하게 되면 새로운 snapshot 이 나온다.

이렇게 만들어진 로컬 커밋을 다른 사람과 공유하기 위해서는, 1. Alex가 다른 사람에게 변경 내용을 보내주기(push), 2. 다른 사람이 Alex의 저장소로부터 변경 내용을 가져가기(pull), 두 가지의 방법이 있다. 어느 쪽이건 다른 저장소에 로컬에서 생긴것과 같은 커밋 및 그에 포함된 객체들이 원격 저장소의 해당 브랜치에 생성되며, 원격 저장소의 작업자는 이렇게 전달된 내용을 검토 후 자신의 작업 브랜치에 머지하거나 새 브랜치를 생성하여 작업을 할 수 있다.

Subversion의 경우와는 달리 Git 모델에서는 작업자가 언제 자신의 작업 내용을 공유할지 선택할 수가 있으며, 이는 공동 작업에서 작업 흐름 관리에 큰 유연성을 준다. 변경 내용이 작은 경우에는 subversion 에서와 같이 바뀐 부분만 저장하는 방식이 바뀐 파일 내용을 모든 커밋이 들고 있는 git의 방식보다 공간 효율성이 더 좋을 수 있다. 이 공간 효율성의 문제에 대해서 git 은 몇 가지 대책을 가지고 있으며, 이는 문서의 뒤쪽에서 설명하게 된다.


## Git 의 선택: The Toolkit

Git은 최초 Linus가 작성한 방식, 그리고 리눅스 커뮤니티에서 시작된 연유로 인해 작은 커맨드라인 도구로 이루어진 툴킷 방식으로 만들어져 있다. 이는 유닉스 커뮤니티의 전통적인 디자인 철학이다. 초기 git 툴킷의 일부는 아예 shell script로 쓰이기도 했는데, 이것이 이식성 문제의 주된 원인이 되기도 했다.

툴킷은 크게 두 부분으로 나뉘는데, 1. Plumbing, 2. Porcelain 파트이다. Plumbing 파트는 저수준의 이력 추적 및 DAG 관련 커맨드라인이 들어있고, Porcelain 파트는 저장소를 다루거나 저장소간의 데이터 전송을 담당하는 작은 명령어들을 가지고 있다.

툴킷 디자인이 스크립트 작성자들에게는 충분한 수준의 커맨드를 제공하고 있지만, 프로그램 개발자들은 자신들의 프로그램에서 링크 가는한 라이브러리가 없다고 불평한다. Git 바이너리가 *die()* 함수를 부르기 때문에 재진입이 가능하지 않고, 대부분의 GUI나 웹 인터페이스 혹은 오랫동안 실행되어야 하는 서비스들에서는 git 실행을 위해서 fork/exec 등을 불러야 하고, 따라서 느리다.

이런 상황을 개선하기 위해 [libgit2](http://libgit2.github.com/) 같은 프로젝트가 진행되고 있다.

## Git internal

### 3단콤보 저장구조

##### 저장소 생성

git이 데이터를 어떻게 구조화하여 저장하는가를 보기 위해 저장소를 만들고 초기화된 저장소가 어떤 구조를 가지는지를 살펴보겠다.

$ mkdir my-repo
$ cd my-repo
$ git init

이렇게 3줄이면 **my-repo** 라는 이름의 git 저장소가 만들어졌다. my-repo 라는 디렉토리는 *비어 있는*, 또한 *초기화된* git 저장소가 되었다. 여러가지 git 명령어를 사용하여 이렇게 새로 생성한 저장소에 커밋, 태그, 브랜치 생성을 하거나 다른 저장소와 통신을 할 수 있다.

*git init* 으로 초기화한 후에 그냥 ls 를 하면 아무것도 보이지 않는다. ls **-a** 옵션을 주면 .git 이라는 이름의 숨은 디렉토리를 하나 볼 수 있는데, 이 숨은 디렉토리가 git 이 초기화를 위해 생성한 내용이다. .git 아래의 구조는 다음과 같다.

~~~
my-repot/.git/HEAD
             +config
             +description
             +hooks/applypatch-msg.sample
             |      commit-msg.sample
             |      post-commit.sample
             |      post-receive.sample
             |      post-update.sample
             |      pre-applypatch.sample
             |      pre-commit.sample
             |      pre-rebase.sample
             |      prepare-commit-msg.sample
             |      update.sample
             +info/exclude
             +objects/info
             |       +pack
             +refs/heads
                  +tags
~~~

용도별로 구분해보자면,

  + Configuration: config, description, info/exclude 는 로컬 저장소의 설정값을 저장하고 있다
      * config 에는 [INI format](http://en.wikipedia.org/wiki/INI_file) 으로 저장소에 대한 설정값들을 가지고 있다. 계정정보 등이 나중에 추가될 수 있다.
      * description 파일은 저장소의 이름 및 설명을 담고 있다. [gitweb](https://git.wiki.kernel.org/index.php/Gitweb) 등의 프로그램은 이 파일을 읽어서 페이지 생성에 사용한다.
      * info/exclude 에는 저장소에 넣지 않을 파일의 패턴을 넣는다. 이것은 로컬 저장소에 적용되는 내용이고, 저장소 자체에 .gitignore 파일을 넣으면 .git/info/exclude와 비슷한 일을 하지만 로컬 저장소 뿐 아니라, .gitignore 가 있는 서브디렉토리에 **언제나** 적용된다. 
  + Hooks: hooks 디렉토리 아래의 파일들은 저장소에 특정 이벤트가 발생할 때 사용된다. 이름으로부터 쉽게 유추할 수 있다. sample 파일을 열어보면 상세하게(영어로...) 설명이 적혀 있다.
  + Staging: index 라는 이름의 파일이 있다. 초기 생성했을 때에는 존재하지 않지만, 저장소에 변화가 생기게 되면 커밋되기 전에 index 파일에 먼저 변경사항이 모이게 된다.
  + Object database: objects 아래에 실제 **로컬** 데이터 객체 및 객체에 대한 포인터들이 모여있다. 데이터 객체는 **한번 생성되면 변하지 않는다**.
  + Reference: refs 아래에는 **로컬 또는 원격** 브랜치, 태그, 헤드에 대한 포인터가 담겨 있다. 레퍼런스는 보통 태그나 커밋에 대한 포인터인데, Object database 밖에 있는 이유는 저장소에 작업 내용이 계속 추가되면서 지속적으로 가리키는 내용이 계속해서 **변하기** 대문이다. 특별히 레퍼런스가 다른 레퍼런스를 가리키는 경우도 있다. HEAD 레퍼런스같은 경우가 그 한 예다.

##### 1단: 저장소(Repository)

이렇게 생성된 .git 디렉토리가 바로 git 이 관리하는 **저장소(repository)** 이다.

##### 2단: 작업 공간(Working directory)

.git 을 포함하는 상위 디렉토리(my_repo)가 작업 공간이다. 이 곳에 현재 작업중인 내용들이 들어있다. 경우에 따라서는 작업 공간 없이 저장소*만* 필요한 경우도 있는데, 저장소를 생성할 때 *git init --bare* 와 같이 **--bare** 명령어를 주면 작업공간을 남겨두지 않고 .git 에 들어갈 내용을 현재 위치한 곳에 생성해 버린다.

##### 3단: 준비 영역(Staging area)

저장소와 작업 공간 사이를 오가기 위한 통로가 필요하다. 위에 잠깐 언급되었듯이 준비 영역의 내용은 .git/index 에 들어있다. 정확히는 준비 영역은 작업 공간과 **로컬** 저장소 사이의 변화를 임시 저장하는 곳이므로, --bare 옵션이 붙어서 작업공간이 마련되지 않은 경우 준비 영역도 없다. 또한 사용자에 의한 작업 공간의 변경사항을 들고 있는 영역이므로 작업 공간이 사용자가 아니라 git 에 의해 수정되는 경우 유실될 수 있다. 이런 경우 git 은 경고나 에러 메시지를 보여준다.


##### 그외 알아두면 덜 헷갈리는 것들

  + HEAD: HEAD 레퍼런스는 작업 공간이 어떤 상태인지를 가리키는 레퍼런스이다.
~~~
git checkout [branch]
~~~
와 같은 명령을 내리면 HEAD 레퍼런스가 해당 브랜치를 가리키도록 가리키고, 작업 공간을 갱신한다.
  + add/rm: 파일의 추가/변경은 git add, 삭제는 git rm 을 통해야 **준비 영역**에 변화 내용이 반영된다. 특히 그냥 쉘의 rm 으로 작업공간을 수정하는 경우 귀찮은 문제가 생긴다. add/rm 명령은 **준비 영역** 만을 수정한다.


정리하면, 내용의 변경이 일어나는 방향과, 이에 관련된 git 명령어는 아래와 같다.

...  그림 그려 넣을것 ...

### Object database

git 은 로컬 저장소의 내용을 저장하기 위해 4가지의 기본 객체 타입을 사용한다. 각 타입은 *type*, *size*, *content* 의 속성을 가지고 있다.

1. Tree: 트리는 다른 트리나 Blob으로 연결된다. 직관적을 알 수 있듯, 트리 객체는 파일시스템의 디렉토리를 나타낸다.
2. Blob: Blob은 하나의 파일을 나타내는 객체이다.
3. Commit: 커밋은 해당 커밋의 **루트 트리**와 **여러개의 부모 커밋**을 가리키는 포인터 객체이다. 
4. Tag: 태그는 이름을 가지고 있으며, 저장소 역사에 있는 특정 커밋을 가리키는 객체이다.

![Git object hierarchy](/aosabook/materials/git/git-object-hierarchy.png)

모든 객체는 40자 길이의 SHA 값을 ID로 가지는데, 이 ID는,

  * 같은 객체라면 같은 SHA 를 가져야 한다
  * 다른 객체끼리는 다른 SHA 를 가져야 한다 
  * 객체가 일부만 복사되었거나 다른 이유로 데이터가 깨진 경우, SHA 를 다시 계산함으로써 데이터가 변조되었는지 확인할 수 있다.

와 같은 성질을 지니고 있다.

Object 를 기본 단위로 하여 DAG 으로 구성하는 git 의 방식은 delta 기반의 저장 방식에 비해서 공간 효율성 면에서 뒤처질 수 있다. Git은 이런 공간 문제에 대해 packing 방식으로 접근한다. 여러개의 Object 를 묶어서 하나의 파일을 생성하고, 이 파일 내에서 각 객체의 위치를 가리키는 index 파일을 만드는 것이다. 기본적으로 object 들 사이에는 중복되는 부분이 많을 수 밖에 없기 때문에 - 이것이 공간 효율성이 떨어지는 이유이기도 하고 - 하나의 파일로 압축하는 경우 압축률은 매우 좋다.

묶음 파일 형식은 파일에 CRC를 넣은 것이 첫번째, 그 다음으로 파일이 아닌 각 객체마다 CRC 를 저장하는 두번째 버전이다. Version 2 에서는 4GB 이상의 묶음 파일을 다룰 수 있으며, 파일 마지막에 포함된 모든 객체의 SHA를 더한 SHA1 sum 을 추가하여 파일이 변조/오염된 경우 쉽게 알아낼 수 있다.

동일 파일이나 디렉토리를 가리키는 객체들이 압축될 때 git 은 마지막 버전을 그대로 넣고, 이전 버전들을 delta 로 저장한다. 이는 최근 파일일 수록 접근이 더 빈번할 것이라는 가정에서이며, 대체로 유효한 가정이다.

Git이 느슨한(loose) 객체들을 묶는 작업은, 1. 알아서 자동으로, 2. remote push 하는 경우, 3. git gc 명령을 실행할 때 일어난다.

자세한 설명은 [이곳](http://git-scm.com/book/en/Git-Internals-Packfiles) 에서 찾을 수 있다.

### 작업 가지(branching) && 가지 잇기(merging)

#### Branching

Git 이 택한 이력 관리 및 저장 구조의 특성은 브랜치를 다루는 데에 특별히 큰 도움이 된다. Subversion 등의 선형 이력을 유지하는 VCS 들은 매 커밋마다 revision 숫자가 올라가고, 더 높은 revision 이 이전 버전을 덮어쓰게 된다. 이 경우 branch는 개념적으로만 존재하며 단순히 디렉토리 구조로만 trunk 와 다른 branch 들을 구분하게 된다. 사실상 브랜치건 뭐건 모두 같은 revision 을 공유하게 되는 것. 따라서 이 경우 디렉토리를 구성하는 방식이 매우 중요하지만, 이는 전적으로 사용자에게 맡겨지고 있다. 전통적인 subversion/cvs 에서의 디렉토리 구조는

~~~ { }
/trunk
/branches/branch-1
         /branch-2
/tags/tag-1
     /tag-2
~~~

이런 모양이며, branching이나 tagging 은 trunk **디렉토리를 복사한 후에 커밋하는 작업일 뿐**이다. 당연히 코드베이스가 커지게 되면 branching/tagging 작업은 매우 느려진다. 가지 합병은 더 큰 일인데 가지의 내용을 trunk에 덮어쓴 후 충돌이 발생하는 부분을 일일이 손으로 고쳐주어야 한다. 더불어 특정 작업 가지의 수정사항이 trunk에 반영된 경우, 이 수정사항을 다른 브랜치에서 알 수 있는 방법이 없다.

Git 의 경우 브랜치나 태그 생성이 매우 빠르다. 모든 브랜치에서 Object DAG 이 공유되고 있으며 각각 commit 의 스냅샷은 객체 레퍼런스들로 구성되기 때문에, **새 브랜치를 만드는 것 역시 특정 commit 에 대한 레퍼런스를 생성**하기만 하면 된다. 그리고 브랜치에 커밋을 하면 지금까지 설명한 대로 현재 commit 을 부모로 하는 새로운 자식 commit이 생성되고, 브랜치의 헤드레퍼런스가 새 commit 을 가리키기만 하면 된다. 이 과정을 간단히 그림으로 보면 아래와 같다. (Images from [http://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging]())

![1. master 만 존재하는 상태](/aosabook/materials/git/git-original.png)   

![2. iss53 브랜치를 만들었다. 레퍼런스가 하나 생겼다!](/aosabook/materials/git/git-branch-iss53.png)  

![3. iss53 에 C3를 커밋했다.](/aosabook/materials/git/git-commit-to-iss53.png)  

#### Merging

합병은 여러개의 커밋 객체를 모아 하나의 커밋 객체를 만드는 작업이다. 일반적으로 브랜치를 머지할 때에는 *두 브랜치의 현재 스냅샷* 과 *각 브랜치의 공통 선조* 를 찾아 3개의 커밋을 합병하여 새로운 커밋을 만든다. 커밋 객체에 중요한 것은 부모와 트리 객체이다.

1. Parents: Target commits
2. Root Tree: Merge each commits' root tree objects

부모는 합병 대상이 되는 커밋들이며, 이는 자명하다. 새 Root tree 객체는 합병 대상의 커밋들이 각각 가지고 있는 root tree 객체들을 합쳐서 만든다. 위에 설명했듯, tree 객체는 **바뀐 부분이 있는 files/subtrees 를 가지는** 구조이다. root tree 는 모두 공통이므로 각 변화사항들이 어디에 위치해야 하는지는 명백하다. **동일 파일의 동일 위치**에 대한 수정사항이 겹치는 경우를 제외하면 merged root tree 객체를 자동으로 생성하여 새 커밋 객체에 붙일 수 있다.

![1. master와 iss53이 각각 진행된 상태](/aosabook/materials/git/git-merge-before.png)  

![2. master와 iss53을 머지하기 위해 재료가 될 커밋들을 골라냄](/aosabook/materials/git/git-merge-prepare.png)  

동일 파일의 동일 위치에 대한 서로 다른 수정사항이 합병되는 경우 충돌(conflict)이 생기고, 이는 사람이 직접 수정해 주어야 한다. 이 경우 최종 커밋 생성이 마무리되지 않은 상태로 사용자에게 제어권이 넘어오게 되며, 충돌이 생긴 파일의 해당 위치에 두 브랜치의 각각 어떤 내용이 있었는지 구분되어 표시가 되어 있다. 이를 수정하여 직접 커밋을 하면 합병이 완료된다. 아래는 master 와 iss53 이 가진 각각의 수정사항에서 충돌이 생긴 경우의 예이다.

~~~ { .html }
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
  please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
~~~

![3. 두 브랜치가 합병된 새 커밋이 생겨 iss53->master 머지 완료](/aosabook/materials/git/git-merge-done.png)  

## 그래서 뭐가 중요해?

1. 저장 구조
    a. Working directory: 작업 공간
    b. Staging area: 작업공간에 딸린 변경사항 저장소
    c. Repository: 객체화되어 저장된 거대한 object storage. 가지, 태그 등은 이 거대 저장소의 한 부분에 대한 레퍼런스일 뿐이다.
2. 객체 종류 및 구성
    a. Tree = Directory
    b. Blob = File
    c. Commit = Parent commits + Tree
    d. Tag = Reference to Commit
3. History(Timeline): DAG of commits

주저리 주저리 많은걸 써 놓았지만 결국 이거만 알면 됨.
