또 번역부터 해 보자...



FreeRTOS는 임베디드 시스템을 위한 오픈소스 실시간 운영체제이다. FreeRTOS는 다양한 아키텍쳐와 컴파일러 툴체인을 지원하고 "작고, 쉽게 사용"할수 있도록 디자인되었다.

FreeRTOS는 활발히 개발중이고 Richard Barry가 2002년부터 시작했다. 나는 FreeRTOS의 개발에 참여하지 않는 단순한 사용자이고 팬이다. 따라서 이 챕터에서는 FreeRTOS가 다른 챕터에서 왜대한 이야기를 하는 것과 달리, 무엇이고 어떻게 작동하는지에 대해 다룰 예정이다.

다른 운영체제와 같이 FreeRTOS의 주된 일은 tasks를 실행하는 것이다. 대부분의 FreeRTOS의 코드는 우선순위 지정, 스케쥴링, 사용자 작업의 실행과 관련되어 있다.

나는 이 챕터를 끝낼때 독자가 FreeRTOS의 기본 아키텍쳐에 대해 이해하기를 바란다. FreeRTOS의 대부분은 tasks의 실행에 연관되어 있기때문에 독자는 FreeRTOS가 이를 어떻게 이를 수행하는지 정확하게 파악할 수 있을것이다.

만약 이 내용이 처음으로 접하는 운영체제 내부에 대한 이야기라면 OS의 작동에 대한 기본을 배울것이라 기대한다. FreeRTOS는 Windows, Linux, OS X 에 비해 상대적으로 간단하지만 모든 운영체제는 유사한 형태와 목표를 공유한다. 따라서 어떤 운영체제를 살펴봐도 유익하고 흥미로울것이다.

#What's "Embedded" and "Real-Time"?

임베디드와 리얼타임은 사람마다 다르게 정의할 수 있기때문에 FreeRTOS의 방식으로 정의 해 보자.

임베디드 시스템은 TV 리모컨의 시스템, 자동차 GPS, 디지털 시계, 심박동기와 같이 제한된 작업만 수행하도록 디자인된 컴퓨터 시스템이다. 임베디드 시스템은 일반적으로 범용 컴퓨터시스템보다 작고 느리며 저렴하다. 일반적인 저급 임베디드 시스템은 25MHz로 작동하는 8비트 CPU, 수 KB의 램, 32KB정도의 플래쉬 메모리로 구성된다. 상급 임베디드 시스템은 750MHz로 작동하는 32비트 CPU와 GB의 램, 수 GB의 플래쉬 메모리로 구성된다.

리얼타임 시스템은 어떤 일을 정해진 시간내에 수행하도록 디자인된다. 제때 일을 수행함을 보장하는 것이다.

심장박동기는 리얼타임 임베디드 시스템의 좋은 예이다. 심장박동기는 당신의 생명을 유지하기 위해 심장 근육을 제시간에 수축시켜야 한다. 이것은 제시간에 응답하지 못할만큼 바빠서는 안된다. 심장박동기와 같은 리얼타임 임베디드 시스템들은 작업을 매번 제시간에 실행하도록 세심히 디자인된다.

#Architecture Overview
FreeRTOS는 상대적으로 작은 애플리케이션이다. FreeRTOS의 최소한의 핵심 부분은 세 개의 .c 파일과 약간의 헤더파일로 구성되며 빈 라인과 주석 포함해 9000라인 정도이다. 일반적인 바이너리 코드 이미지는 10KB보다 작다.

FreeRTOS의 코드는 세 부분으로 나누어볼 수 있다 : tasks, communication, hardware interfacing

- Tasks: FreeRTOS 코드의 거의 절반은 많은 운영체제의 핵심 문제를 다룬다. 바로 tasks!. Task는 우선순위가 주어진 사용자 정의 C 함수이다. tasks.c/tasks.h는 생성, 스케쥴링, 관리와 관련된 힘든 일들을 담당한다.

- Communication: Tasks들은 좋지만 이들이 서로 통신한다면 더 좋다! FreeRTOS의 두번째 일인 communication에 대해 이야기하자. FreeRTOS 핵심 코드의 약 40%는 communication과 관련되어 있다. queue.c와 queue.h는 FreeRTOS의 통신을 담당한다. Tasks와 인터럽트들은 각자 데이터 전달을 위해 queues를 사용하고 세마포어와 뮤텍스를 이용하여 독점적인 자원 사용을 알린다.

- The Hardware Whisperer :  FreeRTOS를 구성하는 약 9000줄의 코드는 하드웨어 독립적이다. FreeRTOS를 실행하는 CPU가 누추한 8051이건 상콤한 ARM core건 같은 코드가 실행된다. 약 6%의 FreeRTOS의 코드가 하드웨어 독립적인 부분과 하드웨어 의존적인 부분의 틈을 매우는 역할을 한다. 다음 섹션에서 하드웨어 의존적인 부분에 대해 이야기 할 것이다.

## Hardware Considerations
FreeRTOS의 하드웨어 독립적인 부분은 하드웨어 의존적인 부분의 위에 놓여 있다. 하드웨어 의존적인 부분은 당신이 선택한 CPU가 무엇이건 제어 방법을 알고 있다. 그림 3.1은 FreeRTOS의 계층구조를 보여준다.

![image](http://www.aosabook.org/images/freertos/freertos-figures-layers.png)
그림 3.1 FreeRTOS의 소프트웨어 계층 구조

FreeRTOS는 실행될 모든 하드웨어 독립/의존 코드를 포함하여 배포된다. 이것은 많은 컴파일러 (CodeWarrier, GCC, IAR, etc..)와 프로세서 아키텍쳐 (ARM7, ARM Cotex-M3, various PICs, Silicon Labs 8051, x86, etc.)를 지원한다. 자세한 정보는 FreeRTOS의 웹사이트를 참고하면된다.

FreeRTOS는 디자인부터 많은 부분이 설정가능하도록 되어 있다. FreeRTOS는 몇몇의 tasks를 지원하는 single CPU의 헐벗은 RTOS부터 TCP/IP, 파일시스템, USB를 지원하는 고성능의 멀티코어 짐승까지 만들어 낼 수 있다.

설정 옵선은 FreeRTOSConfig.h의 #define을 설정해서 지정 가능하다. Clock speed, heap size, mutexes, API subsets 등등의 많은 옵션들이 이 파일로 설정 가능하다. 아래에 maximum number of task priority levels, the CPU frequency, the system tick frequency, the minimal stack size, the total heap size를 설정하는 예제를 보인다.

~~~ {.c}
#define configMAX_PRIORITIES      ( ( unsigned portBASE_TYPE ) 5 )
#define configCPU_CLOCK_HZ        ( 12000000UL )
#define configTICK_RATE_HZ        ( ( portTickType ) 1000 )
#define configMINIMAL_STACK_SIZE  ( ( unsigned short ) 100 )
#define configTOTAL_HEAP_SIZE     ( ( size_t ) ( 4 * 1024 ) )
~~~

하드웨어 의존 코드는 각 컴파일러 툴체인 및 CPU 아키텍쳐를 위한 파일에 분리되어 있다. 예를 들어, ARM Cortex-M3와 IAR compiler를 사용중이라면 하드웨어 의존 코드는 FreeRTOS/Source/portable/IAR/ARM_CM3 디렉토리에 있을것이다. portmacro.h는 모든 하드웨어 종속 기능을 선언하고 있지만, port.c와 portasm.c에 실제 하드웨어 의존  코드가 구현되어 있다. 하드웨어 독립적인 헤더 파일 portable.h는 컴파일 할 때 올바른 portmacro.h를 #include한다. FreeRTOS는 portmacro.h에 #define으로 선언되어 있는 하드웨어 종속 함수를 호출한다.

FreeRTOS가 하드웨어 종속 함수를 호출하는 방법을 한 번 보자. 하드웨어 독립적인 파일인 tasks.c는 종종 선점을 막기 위해 cretical section에 진입 할 필요가 있다. critical section진입 방법은 아키텍쳐 마다 다르고 하드웨어 독립적인 tasks.c는 하드웨어 종속적인 세부사항을 알고싶지 않다. 따라서 tasks.c는 전역 매크로인 portENTER_CRITICAL()을 호출하고, 어떻게 동작하는지는 기꺼이 모른체 한다. ARM Cortex-M3아키텍쳐와 IAR 컴파일러를 쓴다고 가정하면 FreeRTOS는 portENTER_CRITICAL()이 정의된 FreeRTOS/Source/portable/IAR/ARM_CM3/portmacro.h와 함께 빌드 된다. 다음과 같다.

~~~ {.c}
#define portENTER_CRITICAL()    vPortEnterCritical()
~~~

vPortEnterCritical()은 실제로 FreeRTOS/Source/portable/IAR/ARM_CM3/port.c에 정의되어 있다. port.c는 하드웨어 종속적이고 IAR 컴파일러와 Cortex-M3칩을 이해하는 코드를 포함하고 있다. vPortEnterCritical()은 하드웨어 종속적인 방법으로 critical section에 진입하고 하드웨어 독립적인 tasks.c로 리턴한다.

portmacro.h파일은 아키텍쳐의 기본 데이터 형식을 정의한다. IAR 컴파일러와 Cortex-M3칩의 경우 basic integer variables, pointers, the system timer tick data type이 다음과 같이 정의되어 있다.

~~~ {.c}
#define portBASE_TYPE  long              // Basic integer variable type
#define portSTACK_TYPE unsigned long     // Pointers to memory locations
typedef unsigned portLONG portTickType;  // The system timer tick type
~~~

이 #define을 이용한 데이터 형식과 함수의 얇은 계층은 복잡해 보이지만 이것은 하드웨어 종속 코드만 수정하고 재 컴파일하여 전혀 다른 시스템용 FreeRTOS를 만들어준다. 그리고 만약 현재 지원하지않는 아키텍쳐용 FreeRTOS를 제작할 경우, 하드웨어 종속적인부분에 비해 훨씬 작은 하드웨어 종속적인 부분만 구현하면 된다.

이상과 같이 FreeRTOS는 하드웨어 종속적인 부분을 C 전처리기 #define 매크로를 이용해 구현 한다. FreeRTOS는 #define을 많은 양의 하드웨어 독립적인 코드에 사용하기도 한다. 임베디드 시스템용이 아닌 어플리케이션에서는 이렇게 #define을 자주 사용하는것은 씻을 수 없는 죄악이지만 많은 소규모의 임베디드시스템에서는 함수 호출의 오버헤드가 더 큰 죄악이다.

# Scheduling Tasks: A Quick Overview
## Task Priorities and the Ready List

각 테스크는 0~configMAX_PRIORITIES-1 사이의 사용자가 할당한 우선순위를 가진다. 예를 들어, 만약 configMAX_PRIORITIES가 5로 설정되어 있다면, FreeRTOS는 5개의 우선순위 레벨을 사용한다 : 0(가장 낮음), 1, 2, 3, 4(가장 높음).

FreeRTOS는 현재 실행 준비 된 tasks를 추적하기 위해 "ready list"를 사용한다. 다음과 같은 task list로 ready list를 구현한다.

~~~{.c}
static xList pxReadyTasksLists[ configMAX_PRIORITIES ];  /* Prioritised ready tasks.  */
~~~

pxReadyTasksLists[0]은 우선순위가 0인 모든 ready tasks의 list 이고, pxReadyTasksLists[1]은 우선순위가 1인 모든 ready tasks의 list이다. 이런식으로 pxReadyTasksList[configMAX_PRIORITIES-1]까지 존재 한다.

## The System Tick

FreeRTOS시스템의 심장박동을 system tick이라 부른다. FreeRTOS는 시스템이 주기적인 tick interrupt를 생성하도록 설정한다. 사용자는 일반적으로 millisecond 범위인 tick interrupt frequency를 설정할수 있다. tick interrupt가 발생 할 때 마다 vTaskSwitchContext()함수가 호출된다. vTaskSwitchContext()는 가장 우선순위가 높은 ready task를 선택한 뒤 pxCurrentTCB를 다음과 같이 설정 한다.

~~~{.c}
/* Find the highest-priority queue that contains ready tasks. */
while( listLIST_IS_EMPTY( %amp;( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
{
    configASSERT( uxTopReadyPriority );
    --uxTopReadyPriority;
}

/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the same 
priority get an equal share of the processor time. */
listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, %amp;( pxReadyTasksLists[ uxTopReadyPriority ] ) );
~~~

while loop가 실행되기 전에, uxTopReadyPriority는 가장 우선순위가 높은 ready task와 같거나 큰 값을 가지고 있음이 보장된다. while() loop는 uxTopReadyPriority애서 시작하여 pxReadyTasksLists[] 배열을 따라 내려가며 ready tasks중 가장 우선순위가 높은 것을 찾는다. listGET_OWNER_OF_NEXT_ENTRY()는 우선순위 레벨의 ready list에서 다음의 ready task를 집어낸다.

이제 pxCurrentTCB는 가장 우선순위가 높은 task를 가리키고, vTaskSwitchContext()가 리턴할 때 그 task를 실행하는 하드웨어 종속적인 코드를 시작한다.

위의 아홉줄의 코드들은 FreeRTOS의 최고 핵심 부분이다. 이외의 8000+ FreeRTOS의 라인들은 이 아홉라인들이 가장 우선순위가 높은 task를 실행할 수 있도록 도와주는 역할을 하는것이다.

그림 3.2는 ready list의 생김새를 대략적으로 보여준다. 이 예에는 세 개의 우선순위가 있는데 하나의 우선순위 0, 우선순위 1은 없고, 세 개의 우선순위 2의 tasks를 보여주고 있다. 이 그림은 정확하긴하지만 완전한건 아니다; 다음에 살펴볼 몇몇 세부사항을 빠트리고 있다.

![image](http://www.aosabook.org/images/freertos/freertos-figures-basic-ready-list.png)
그림 3.2 Basic view of FreeRTOS Ready List

지금까지 대충 둘러봤으니 이제 세부사항을 살펴 볼 차례이다. 다음 절에서 세 개의 주요 FreeRTOS의 데이터 구조를 살펴 본다: tasks, lists, queues.

# Tasks

Tasks의 실행과 운용은 모든 운영체제의 핵심 작업이다. 많은 운영체제들과 유사하게, FreeRTOS의 기본 작업 단위는 task이다. FreeRTOS는 각 task를 나타내기 위해 Task Control Block(TCB)를 사용한다.

## Task Control Block (TCB)

TCB는 tasks.c에 다음과 같이 정의되어 있다:

~~~ {.c}
typedef struct tskTaskControlBlock
{
  volatile portSTACK_TYPE *pxTopOfStack;                  /* Points to the location of
                                                             the last item placed on 
                                                             the tasks stack.  THIS 
                                                             MUST BE THE FIRST MEMBER 
                                                             OF THE STRUCT. */
                                                         
  xListItem    xGenericListItem;                          /* List item used to place 
                                                             the TCB in ready and 
                                                             blocked queues. */
  xListItem    xEventListItem;                            /* List item used to place 
                                                             the TCB in event lists.*/
  unsigned portBASE_TYPE uxPriority;                      /* The priority of the task
                                                             where 0 is the lowest 
                                                             priority. */
  portSTACK_TYPE *pxStack;                                /* Points to the start of 
                                                             the stack. */
  signed char    pcTaskName[ configMAX_TASK_NAME_LEN ];   /* Descriptive name given 
                                                             to the task when created.
                                                             Facilitates debugging 
                                                             only. */

  #if ( portSTACK_GROWTH > 0 )
    portSTACK_TYPE *pxEndOfStack;                         /* Used for stack overflow 
                                                             checking on architectures
                                                             where the stack grows up
                                                             from low memory. */
  #endif

  #if ( configUSE_MUTEXES == 1 )
    unsigned portBASE_TYPE uxBasePriority;                /* The priority last 
                                                             assigned to the task - 
                                                             used by the priority 
                                                             inheritance mechanism. */
  #endif

} tskTCB;
~~~

TCB는 스텍의 시작주소를 pxStack에 저장하고 스텍의 최 상위 주소를 pxTopOfStack에 저장한다. 또한, 스텍의 끝 주소를 pxEndOfStack에 저장하여 스텍 넘침을 체크한다. 스택이 아래쪽으로 넘치는 것 역시 pxTopOfStack과 pxStack을 비교하여 체크한다.

TCB는 task의 초기 우선순위를 uxPriority와 uxBasePriority에 저장한다. Task는 생성될 때 우선순위가 주어지고, 이는 변경될 수 있다. 만약 FreeRTOS가 우선순위 상속을 구현하고 있으면 task가 임시적으로 상속된 우선순위로 변경되어 있는 동안 uxBasePriority를 원래 우선순위를 기억하는데 사용한다. (아래에서 뮤텍스에 관해 이야기 할 때 우선순위 상속에 대해 좀 더 이야기 할것이다.)

각 task는 FreeRTOS의 다양한 scheduling list를 사용하기 위한 두 개의 list를 가지고 있다. task를 list에 넣을 때 FreeRTOS는 TCB에 포인터를 직접 넣지 앟는다. 대신에, FreeRTOS는 포인터를 TCB의 xGenericListItem또는 xEventListItem에 넣어둔다. 이 xListItem 변수들은 TCB에 단순히 포인터를 넣어두는 것 보다 FreeRTOS의 lists를 똑똑하게 한다. 다음에 list에 대해 이야기 할 때 이에대한 예를 볼 수 있다.

task는 다음의 네 가지 상태를 가진다: running, ready to run, suspended, blocked. 당신은 각 task가 자신의 상태에대한 변수를 가질것이라고 기대하겠지만, 그렇지 않다. 대신에, FreeRTOS는 task를 적절한 list에 넣어둠으로써 task의 상태를 암시적으로 추적한다 이 list는 ready list, suspended list 등이다. 특정 list에 task가 소속된다는 것은 그 task의 상태를 나타내는것과 같다. Task의 상태를 변경하는 것은 그냥 하나의 list에서 다른 list로 옮기는 작업인 것이다.

## Task Setup

우리는 이미 pxReadyTasksLists를 사용해 task가 선택되고 스케쥴되는 방법에 대해 알아본 적이 있다. 이제는 task가 생성되는 방법을 알아보자. task는 xTaskCreate()가 호출되면 생성된다. FreeRTOS는 새로 TCB를 할당하고 이름, 우선순위 등의 task의 세부사항을 지정하고 사용자가 요청한 스택을 할당하고 TCB의 pxStack 멤버에 스택 메모리의 시작 주소를 저장한다.

스택은 새 task가 이미 실행중이거나 문맥전환에 의해 인터럽트되어 있는지 살펴보기 위해 초기화된다. 이 방법은 스케쥴러가 새로 만든 task나 동작중인 task를 정확히 같은 방법으로 다룰 수 있게 해준다. 따라서 스케쥴러는 새로운 task를 위한 특별한 코드가 필요 없어 진다.

task의 스택이 만들어지는 방법은 FreeRTOS가 실행되는 아키텍쳐에 따른  문맥전환에 의한 인터럽트와 비슷하다 다음의 ARM Cortex-M3 프로세서의 구현이 좋은 예이다.

~~~ {.c}
unsigned int *pxPortInitialiseStack( unsigned int *pxTopOfStack, 
                                     pdTASK_CODE pxCode,
                                     void *pvParameters )
{
  /* Simulate the stack frame as it would be created by a context switch interrupt. */
  pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on 
                     entry/exit of interrupts. */
  *pxTopOfStack = portINITIAL_XPSR;  /* xPSR */
  pxTopOfStack--;
  *pxTopOfStack = ( portSTACK_TYPE ) pxCode;  /* PC */
  pxTopOfStack--;
  *pxTopOfStack = 0;  /* LR */
  pxTopOfStack -= 5;  /* R12, R3, R2 and R1. */
  *pxTopOfStack = ( portSTACK_TYPE ) pvParameters;  /* R0 */
  pxTopOfStack -= 8;  /* R11, R10, R9, R8, R7, R6, R5 and R4. */
  
  return pxTopOfStack;
}
~~~

ARM Cortex-M3 프로세서는 task가 인터럽트되었을 때 레지스터를 스택에 푸쉬한다. pxPortInitialiseStack()은 task가 실제로 작동이 시작된 적이 없더라도 레지스터들이 푸쉬 되었던 것 처럼 스택을 고친다. ARM 레지스터인 xPSR, PC, LR, R0를 위해 알려진 값들이 스택에 저장된다. 남아 있는 R1 ~ R12 레지스터들은 최상위 스택 포인터를 아래로 내림으로써 그들을 위한 스텍 공간을 얻어내지만, 이 레지스터들을 위한 특별한 값이 스택에 저장되지는 않는다. ARM 아키텍쳐는 이 레지스터들은 리셋될 때의 값이 정의되지 않았다고 말하기 때문에, 프로그램은 알려진 값을 넣지 않는것이다.

스택이 준비되면 task는 거의 실행 준비가 된 것이다. 하지만 먼저 FreeRTOS는 인터럽트를 꺼야한다: 우리는 지긋지긋한 ready list들과 기타 스케쥴러 구조체들에 둘러쌓이기 시작할 것이고, 우리가 모르는 사이에 이것들을 변경하기를 원치 않는다.

만약 이것이 가장 첫 task라면, FreeRTOS는 스케쥴러의 task lists를 초기화 한다. FreeRTOS의 스케쥴러는 pxReadyTasksLists[]라는 ready list의 배열을 가지고 있다. 이것은 각각의 가능한 우선순위에 대하 하나씩의 리스트를 가진다. FreeRTOS는 tasks가 suspended, killed, delayed가 되었는지 추적하기 위한 별도의 리스트도 가지고 있다. 이것들고 이 때 초기화 된다.

첫 번째 초기화를 하고 나면 새로운 task는 지정된 우선순위에 따른 ready list에 추가된다. 인터럽트는 다시 켜지고 새로운 task의 생성은 완료된다.

# Lists

