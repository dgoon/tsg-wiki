# Processing.js

## 번역

(을 시도해 봅니다...)

원래 Ben Fry와 Casey Reas에 의해 개발된 프로세싱 프로그래밍 언어는 일렉트로닉 아트와 비쥬얼 디자인 커뮤니티가 비쥬얼 컨텍스트 내에서 기본적인 컴퓨터 프로그래밍을 배우는 것을 돕기 위한 (자바 기반의) 오픈 소스 프로그래밍 언어로 시작되었다. 대부분의 프로그래밍 언어들과 비교되는 2D와 3D 그래픽스를 위한 매우 단순화된 모델을 제공한 것은, 그것이 광범위한 활동(작은 시각화를 작성하는 것을 통해 프로그래밍을 가르치는 것 부터 multi-wall art installations을 창조하는 것까지)을 위해 빠르게 잘 적용되었고, 다양한 여러가지 작업(간단히 문자열들의 배열를 읽는 것에서 부터 대중적인 아두이노 오픈 소스 하드웨어 프로토타이핑 보드를 프로그래밍하고 구동하기 위한 거의 표준의 IDE로써 동작하는 것까지)을 수행할 수 있게 되었다. 계속 인기를 얻고 있는 프로세싱은 배우기 쉽고, 모든 보여지는 것과 그 이상의 것을 위한 널리 사용되는 프로그래밍 언어로써 그 자리를 확고히 하고 있다.

스케치(sketch)라고 불리는 기본적인 프로세싱 프로그램은 두개의 함수로 구성되어 있다: `setup`과 `draw`. 첫번째는 주 프로그램의 엔트리 포인트로, 초기화 명령의 상당량을 포함할 수 있다. `setup`이 끝난 후, 프로세싱 프로그램은 두가지 중 하나를 할 수 있다: 1) `draw`를 호출하고 완료될 때까지 고정된 간격으로 그려주기 위해 하기 위해 다른 호출을 예정하는 것 또는 2)`draw`를 호출하고 사용자로 부터 입력을 대기하는 것. 기본적으로 프로세싱은 전자처럼 동작하고, `noLoop`를 호출할 경우 후자 처럼 동작한다.이것은 스케치를 표시하는데 두 가지 모드를 허용하는데, 다시 말하면 고정된 프레임레이트의 그래픽 환경과, 상호적이고 이벤트에 기반하여 업데이트되는 그래픽 환경이다. 두 경우 모두, 사용자 이벤트는 감시되고, 그들 자신의 이벤트 처리기나 `draw` 함수에 직접적으로 persistent global values에 설정된 특정 이벤트로 처리될 수 있다.

Processing.js는 Java 또는 플러그인의 필요 없이 웹에 프로세싱을 가져오기 위해 설계된 자매 프로젝트이다. 이것은 John Resig에 의해 2008년에 대중에게 공개된 컨셉 라이브러리의 증거와 함께 그래픽 컨텍스트로-당시에는 아주 새로웠던-HTML5 `<canvas>` 요소를 사용함으로써 프로세싱 언어가 웹으로 이식될 수 있다는 것을 보여주는 시도로 부터 시작되었다. "your code should just work"는 아이디어를 염두하고 쓰여진 Processing.js는 어떤 플러그인도 없이 웹 표준만을 사용하여 동작하는 시각화, 디지털 아트, 인터랙티브 애니메이션, 교육적 그래픽, 비디오 게임 등의 데이터를 만들기 위해 수년에 걸쳐 개선되었다. 당신이 프로세싱 IDE나 선호하는 에디터에서 프로세싱 언어를 사용하여 코드를 작성하고 `<canvas>` 요소를 사용하는 웹페이지에 그것을 포함하면, Processing.js는 `<canvas>` 요소 안에 모든 것을 렌더링하고, 평범한 스탠드얼론 프로세싱 프로그램이 하는 것과 같은 방법으로 사용자가 그래픽스와 소통할 수 있게 하는 나머지 작업을 한다.

**17.1. 어떻게 작동하나?**

Processing.js는 그것의 코드 기반이 전체 라이브러리를 구성하는 단일 객체인 프로세싱을 위한 코드를 담고 있는 `processing.js`라고 불리우는 하나의 파일이라는 것에서 오픈 소스 프로젝트로써 약간 특이하다. 코드를 구성하는 방법 측면에서, 매 릴리즈와 함께 이 객체에 대한 약간의 청소를 시도할 때마다 우리는 끊임없이 그것 내부 주변의 것들을 정리한다. 그것의 설계는 비교적 간단하며, 그것의 함수는 하나의 문장으로 설명될 수 있다: 이것은 프로세싱 소스 코드를 순수 자바스크립 소스 코드로 재작성한 것이고 모든 프로세싱 API 함수 호출은 자바스크립트 프로세싱 객체에 대응되는 함수로 매핑될 수 있다. 그 함수 호출은 프로세싱 호출이 자바 애플릿 캔버스 상에 미치는 결과와 동일한 것을 `<canvas>` 상에 가져온다. (번역주: 한문장인데 번역이 힘들어서 두문장으로 잘랐습니다. ㅠ.ㅠ)

속도에 대해, 우리는 2D와 3D 함수를 위한 두가지 분리된 코드 경로를 가지고 있다. 그리고 스케치가 로드 될 때 하나 또는 다른 하나는 실행 중인 객체에 부풀린 것을 추가하지 않는 것을 해결하기 위핸 함수 랩퍼들을 위해 사용된다. 그러나, 자료 구조와 코드 흐름 측면에서 자바스크립트를 아는 것은 당신이 구문 해석기의 가능한 예외와 함께 `processing.js`를 읽을 수 있다는 것을 의미한다.

**자바와 자바스크립트 통합하기**

프로세싱 소스 코드를 자바스크립트 소스 코드로 재작성하는 것은 당신이 간단히 브라우저에게 재작성된 소스코드를 실행하라고 말할 수 있다는 것을 의미하며, 만약 그것을 정확히 재작성했다면, 그것은 그냥 작동한다. 하지만 재작성한 것이 정확한지 확인하는 것은 시간이 걸리고, 때때로 꽤 많은 노력이 필요하다. 프로세싱 문법은 자바에 기반한다. 그것은 Processing.js가 본질적으로 자바 소스 코드를 자바스크립트 소스 코드로 변환해야함을 의미한다. 초기에 이것은 문자열로써 자바 소스 코드를 다루어, 반복적으로 자바의 부분문자열을 자바스크립트에서 그것과 동등한 것으로 대체함으로써 달성되었다.(파서의 초기 화신에 관심있는 분들에 대해, 그것은 실행 중인 라인 37에서 라인 266에서 찾을 수 있다.) 작은 문법 집합에 대해 이것은 좋은 방법이지만 시간이 지날수록 복잡도에 복잡도가 추가되어 이런 접근은 망가지기 시작했다. 그 결과, 파서는 처음 자바 소스 코드를 함수 블록으로 분해하는 것 대신 이러한 블록을 대응되는 자바스크립트 문법으로 맵핑하는 추상 구문 트리(AST)를 생성하기 위하여 완전히 재작성되었다. 그 결과 가독성의 비용 측면에서, Processing.js는 현재 효과적으로 on-the-fly 자바-대-자바스크립트 변환컴파일러를 포함하게 되었다. (독자들은 19217줄까지 이 코드를 정독해도 좋다.)

이것은 프로세싱 스케치를 위한 코드이다:

~~~ { .java }
    void setup() {
      size(200,200);
      noCursor();
      noStroke();
      smooth(); }

    void draw() {
      fill(255,10);
      rect(-1,-1,width+1,height+1);
      float f = frameCount*PI/frameRate;
      float d = 10+abs(60*sin(f));
      fill(0,100,0,50);
      ellipse(mouseX, mouseY, d,d); }
~~~

그리고 이것은 위의 Processing.js 변환이다:

~~~ { .javascript }
    function($p) {
        function setup() {
            $p.size(200, 200);
            $p.noCursor();
            $p.noStroke();
            $p.smooth(); }
        $p.setup = setup;

        function draw() {
            $p.fill(255, 10);
            $p.rect(-1, -1, $p.width + 1, $p.height + 1);
            var f = $p.frameCount * $p.PI / $p.__frameRate;
            var d = 10 + $p.abs(60 * $p.sin(f));
            $p.fill(0, 100, 0, 50);
            $p.ellipse($p.mouseX, $p.mouseY, d, d); }
        $p.draw = draw; }
~~~

이것은 굉장한 것 처럼 들리지만, 자바 문법을 자바스크립트로 변환할 때 몇가지 문제가 있다:

1. 자바 프로그램은 고립된 개체이지만, 자바스크립트 프로그램은 웹 페이지와 세계를 공유한다.
1. 자바는 강타입이고, 자바스크립트는 그렇지 않다.
1. 자바는 클래스/인스턴스 기반의 객체 지향 언어이고, 자바스크립트는 그렇지 않다.
1. 자바는 구분된 변수와 함수를 가지고 있지만, 자바스크립트는 그렇지 않다.
1. 자바는 함수 오버로딩을 허용하지만, 자바스크립트는 그렇지 않다.
1. 자바는 컴파일된 코드를 가져오는 것을 허용하지만, 자바스크립트는 심지어 그게 뭘 뜻하는지조차 모른다.

이러한 문제를 다루는 것은 사용자가 요구하는 것과 우리가 주어진 웹 기술로 할 수 있는 것 사이에 트레이드오프가 되었다. 다음 섹션은 좀 더 자세히 이러한 이슈 각각에 대해 논의하게 될 것이다.

**17.2. 상당한 차이점들**

**자바 프로그램은 그들 자신의 스레드를 갖는다; 자바스크립트는 당신의 브라우저를 쓸 수 없게 만들 수 있다.**

자바 프로그램은 당신 시스템 상의 응용 프로그램의 보다 큰 풀 안에 있는 그들 자신의 스레드 내에서 실행되는 고립된 개체이다. 반면에, 자바스크립트 프로그램은 브라우저 내에 살고, 
데스크탑 응용 프로그램이 하지 않는 방법으로 서로 경쟁한다.

Java programs are isolated entities, running in their own thread in the greater pool of applications on your system. JavaScript programs, on the other hand, live inside a browser, and compete with each other in a way that desktop applications don't. When a Java program loads a file, the program waits until the resource is done loading, and operation resumes as intended. In a setting where the program is an isolated entity on its own, this is fine. The operating system stays responsive because it's responsible for thread scheduling, and even if the program takes an hour to load all its data, you can still use your computer. On a web page, this is not how things work. If you have a JavaScript "program" waiting for a resource to be done loading, it will lock its process until that resource is available. If you're using a browser that uses one process per tab, it will lock up your tab, and the rest of the browser is still usable. If you're using a browser that doesn't, your entire browser will seem frozen. So, regardless of what the process represents, the page the script runs on won't be usable until the resource is done loading, and it's entirely possible that your JavaScript will lock up the entire browser



## Links

(일단 링크 수집...)

* [aosabook 본문 링크](http://www.aosabook.org/en/pjs.html)
* [processing.js 공식 사이트](http://processingjs.org)
* [processing.js repository (github)](https://github.com/processing-js/processing-js)